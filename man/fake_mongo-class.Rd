% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FakeMongo.R
\docType{class}
\name{fake_mongo-class}
\alias{fake_mongo-class}
\alias{fake_mongo}
\alias{mdbAggregate,fake_mongo-method}
\alias{mdbCount,fake_mongo-method}
\alias{mdbDisconnect,fake_mongo-method}
\alias{mdbDistinct,fake_mongo-method}
\alias{mdbDrop,fake_mongo-method}
\alias{mdbExport,fake_mongo-method}
\alias{mdbImport,fake_mongo-method}
\alias{mdbFind,fake_mongo-method}
\alias{mdbIndex,fake_mongo-method}
\alias{mdbInfo,fake_mongo-method}
\alias{mdbInsert,fake_mongo-method}
\alias{mdbIterate,fake_mongo-method}
\alias{mdbMapreduce,fake_mongo-method}
\alias{mdbRemove,fake_mongo-method}
\alias{mdbRename,fake_mongo-method}
\alias{mdbReplace,fake_mongo-method}
\alias{mdbRun,fake_mongo-method}
\alias{mdbUpdate,fake_mongo-method}
\alias{showDatabases,fake_mongo-method}
\alias{showCollections,fake_mongo-method}
\title{A simulated `MongoDB` object for testing}
\usage{
fake_mongo(
  collection = "test",
  db = "test",
  url = "mongodb://localhost",
  verbose = FALSE,
  options = mongolite::ssl_options(),
  noMongo = TRUE,
  logging = TRUE,
  aggregate = list(),
  count = list(),
  distinct = list(),
  find = list(),
  iterate = list(),
  mapreduce = list(),
  run = list(),
  databases = list(),
  collections = list()
)

\S4method{mdbAggregate}{fake_mongo}(
  db,
  pipeline = "{}",
  options = "{\\"allowDiskUse\\":true}",
  handler = NULL,
  pagesize = 1000,
  iterate = FALSE
)

\S4method{mdbCount}{fake_mongo}(db, query = "{}")

\S4method{mdbDisconnect}{fake_mongo}(db)

\S4method{mdbDistinct}{fake_mongo}(db, key, query = "{}")

\S4method{mdbDrop}{fake_mongo}(db)

\S4method{mdbExport}{fake_mongo}(
  db,
  con = stdout(),
  bson = FALSE,
  query = "{}",
  fields = "{}",
  sort = "{\\"_id\\":1}"
)

\S4method{mdbImport}{fake_mongo}(db, con = stdout(), bson = FALSE)

\S4method{mdbFind}{fake_mongo}(
  db,
  query = "{}",
  fields = "{\\"_id\\":0}",
  sort = "{}",
  skip = 0,
  limit = 0,
  handler = NULL,
  pagesize = 1000
)

\S4method{mdbIndex}{fake_mongo}(db, add = NULL, remove = NULL)

\S4method{mdbInfo}{fake_mongo}(db)

\S4method{mdbInsert}{fake_mongo}(db, data, pagesize = 100, stop_on_error = TRUE, ...)

\S4method{mdbIterate}{fake_mongo}(
  db,
  query = "{}",
  fields = "{\\"_id\\":0}",
  sort = "{}",
  skip = 0,
  limit = 0
)

\S4method{mdbMapreduce}{fake_mongo}(db, map, reduce, query = "{}", sort = "{}", limit = 0)

\S4method{mdbRemove}{fake_mongo}(db, query = "{}", just_one = FALSE)

\S4method{mdbRename}{fake_mongo}(mdb, name, db = NULL)

\S4method{mdbReplace}{fake_mongo}(db, query, update = "{}", upsert = FALSE)

\S4method{mdbRun}{fake_mongo}(db, command = "{\\"ping\\":1}", simplify = TRUE)

\S4method{mdbUpdate}{fake_mongo}(
  db,
  query,
  update = "{\\"$set\\":{}}",
  filters = NULL,
  upsert = FALSE,
  multiple = FALSE
)

\S4method{showDatabases}{fake_mongo}(
  db = NULL,
  uri = "mongodb://localhost",
  options = mongolite::ssl_options()
)

\S4method{showCollections}{fake_mongo}(
  db = NULL,
  dbname = "test",
  uri = "mongodb://localhost",
  options = mongolite::ssl_options()
)
}
\arguments{
\item{collection}{character -- name of the referenced collection}

\item{db}{character -- name of the referenced database}

\item{url}{character -- URI for accessing the database.}

\item{verbose}{logical -- passed to `\link[mongolite]{mongo}`}

\item{options}{ANY -- SSL options passed to `mongo` call.}

\item{noMongo}{logical -- If true (default), no attempt is made to connect to the Mongo database.}

\item{logging}{logical -- If true (default), then calls to the database will be logged.}

\item{aggregate}{list -- simulated responses from [mdbAggregate()] queries.}

\item{count}{list -- simulated responses from [mdbCount()] queries.}

\item{distinct}{list -- simulated responses from [mdbDistinct()] queries.}

\item{find}{list -- simulated responses from [mdbFind()] queries.}

\item{iterate}{list -- simulated responses from [mdbIterate()] queries.}

\item{mapreduce}{list -- simulated responses from [mdbMapreduce()] queries.}

\item{run}{list -- simulated responses from [mdbRun()] queries.}

\item{databases}{list -- simulated responses from [showDatabases()] queries.}

\item{collections}{list -- simulated responses from [showCollections()] queries.}

\item{pipeline, handler, pagesize, query, key, fields, sort, skip, limit, map, reduce, command, simplify, uri, dbname, con, bson, add, remove, data, stop_on_error, just_one, mdb, name, update, upsert, filters, multiple, ...}{--
arguments to the generic functions which are ignored in the `fake_mongo` methods.}
}
\value{
An object of class `fake_mongo`

An object of type `\linkS4class{fake_mongo}
}
\description{
This class simulates the behavior of a mongo collection providing a set of scripted responses to queries.  In particular,
[mdbAggregate()], [mdbCount()], [mdbDistinct()], [mdbFind()], [mdbIterate()], [mdbMapreduce()],
[mdbRun()], [showCollections()] and [showDatabases()] methods are overridden to return prespecified
results in order.  Usually, no connection is made to an actual database, so this can be used to run tests
in environments where it is unknown whether or not an appropriate mongo database is available.
}
\details{
Internally the `fake_mongo` class has a list of iterators named "aggregate", "count", "distinct", "find",
"iterate", "mapreduce", "run", "databases", and "collections".  The corresponding methods will return the next entry
in the iterator (if it exists) or else will call the parent method to get the default return value (varies with generic
function).  Usually, no connection to a mongo database is made.


 The Queue names are given in the following table.
  \tabular{rr}{
   \strong{Method} \tab \strong{Queue Name} \cr
   \code{\link{mdbAggregate}} \tab "aggregate" \cr
   \code{\link{mdbCount}} \tab "count" \cr
   \code{\link{mdbDistinct}} \tab "distinct" \cr
   \code{\link{mdbFind}} \tab "find" \cr
   \code{\link{mdbIterate}} \tab "iterate" \cr
   \code{\link{mdbMapreduce}} \tab "mapreduce" \cr
   \code{\link{mdbRun}} \tab "run" \cr
   \code{\link{showCollections}} \tab "collections" \cr
   \code{\link{showDatabases}} \tab "databases" \cr
 }

These names are used as `which` arguments to the `$que(which)` and `$resetQueue(which)`
methods as well as for initializing the queue using the `fake_mongo` constructor.

If logging is turned on (either by setting `logging=TRUE` in the constructor, or by calling
`$logging(TRUE)`, then each `mdbXXX` method will log the call to the `log` collection.
The `$getLog()` and `$lastLog()` methods access the queue, and `$resetQueue()` resets it.
}
\section{Functions}{
\itemize{
\item \code{fake_mongo()}: Constructor

}}
\section{Fields}{

\describe{
\item{\code{queues}}{a named list of `\linkS4class{iterator}` objects which provide the simulated responses.}

\item{\code{log}}{a list of database calls made}

\item{\code{logp}}{logical If `TRUE` then method class will be logged.

# Methods
* `$que(which)` -- Returns the internal iterator associated with the operation `which`.
* `$resetQue(which,newElements)` -- Calls `$reset()` method on `$que(which)`.
* `$resetAll()` -- resets all queues
* `$logging(newState)` -- Checks whether or not logging is currently being done.  If `newState` is
supplied, the logging is turned on or off.
* `$logCall(call)`  -- if logging is turned on, `call` is added to the log.
* `$getLog(newestFirst=TRUE)` -- returns the entire log.  If argument is `FALSE` order is reversed.
* `$lastLog()` -- returns the most recently added element in the log.
* `$resetLog()` -- clears the log.}
}}


\examples{
showClass("fake_mongo")
}
